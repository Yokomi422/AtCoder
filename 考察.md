考え方
1.わからなくても入力例からわかることもある。
2.部分的にWAになってしまった時は、境界例・例外を考える。ちょっとだけ変えてすぐ提出することのないようにする
3.簡単なケースから実験してみる・実は順番が関係なかったとかもあり


数学的考察
1.余りとか商とか 2.パリティ3.最大公約数・最大公約数4.不変量5.mod 6.必要条件と十分条件

よく使う手法
1.ソート2.関数からの複数の返値　https://www.techiedelight.com/ja/return-multiple-values-functions-cpp/
3.

#記法
1.map = mp 2. max = mp

予期せぬエラー
1.リストのインデックスがout of rangeの可能性 cin >> A[] ではなく、いったん文字でおいてから代入とか at.()を試す。
2.実験時の値を解答に使ってしまっている
3.範囲の際どい箇所でも成立しているか確認
4.代入忘れを多々あります
５.

TLEの対処法
1.計算量を予め考慮する2. 答えから規則を探す(図示するといい) 3. 全探索では終わらないことを認める 4.for文を減らそうとする。少し変更しただけではTLEは無くならない


#問題パターン#
1.グリッド問題
  1.Pを並び替えてQにできるかどうかは両方をsortして同じになるかを考える
  2.転置の方法 転置用の配列Taを用意してTa[i].push_back()していけばいい。文字列の+とかをするとできない。添え字を間違えないように。
  3.トーラス問題 i = (i + n)%n　C++では商が負になる時は注意 int dx[] = {}
  4.8近傍移動問題 (i + di, j + dj)で実行する
  5.数字が一列で入力されるときはstringで読み込む
  6.ある点から進めるマスは全部で何マス？ dp
  7.無限ループをどうやって処理するか　同じマスに二回以上訪れるならループが始まる vector<vector><bool>>で保存するといい visited

2.文字列問題
　1.回文判定　reserseしてそれが元の文字列と同じかを確認　数字の回文を求める場合は数字の半分を全列挙すればいい カーソル(l,r)を用意する(
  l,rを足す１するということが)
　2.アナグラム sortして同じになるか
　3.mapはkeyでソートされる
　4.いつもと違う順番の昇順　普通の順番に戻して次にいつもと違う順番に戻す mapで管理する
　5.'a' - 0とすることで小文字アルファベットのASCIIコードを出すよ。

3.

4.グラフの問題
 1.
 2.パスグラフ(頂点が一列に並んでいる,UnionFind)
 3.単純グラフは自分と繋がっている点がなく多重辺もない。
 4.字数(degree)に注目する
 5.閉路問題 閉路にするために取る最小値を求めたいなら、頂点集合から始めて最大何本足せるかを考えればいい。
 6.連結成分ごとに考察する
 7.木(閉路がないグラフ・辺の個数がn-1本(nは頂点数)) 森　既に連結になっているニ頂点に辺を張ると必ず閉路が生まれる
 　1.完全二分木 トーナメント問題　m人のトーナメントであればm-1回の戦いが行われる(一回戦うと1人負ける)
 8.graphにソートを加えたいとき for (auto &graph : G) sort(graph.begin(), graph.end());とするといい　変更を維持したいときにポインタを使おう

5.文字列操作
　1.長い数字などは文字列で受け取るといいかも
　2.str.find()はcharが文字列のどこにあるかをindexで教えてくれるよ
　3.連結 str(変数) + str(変数)　または str(変数) + "" または str(変数).append("")
　4.str.erase(何番目の文字,その数から何文字を消すか)で文字列の削除が可能


6.ゲームの最適化問題
 1.前半の人の結果を所与として後半の最適化を考える
 2.ほぼどっちかが勝つことに注目してもいい
 3.

7.条件を満たす組み合わせは存在するか問題
 1.全探索
 2.使う個数を決め撃ちして全探索 不等式を満たす?

8.vector操作
　1.配列の先頭に要素を追加するときはinsertを使う(insert(vect.begin(),a))　しかしこれの計算量はO(n) vec.emplace(vec.begin(),a)とするとO(1)にる
　2.配列の末尾に要素を追加するときはpush_backを使う たまに計算量がnになることがあるので注意 vector.reverse(桁数)で予め桁数を指定しておくといいかも
　3.配列の最後削除するときはpop_backを使う
　4.配列の最後の要素を取得するときはback()を使う

9.dequeの勧め
　1.任意のインデックスにアクセス可能な上、先頭と末尾に要素を追加・削除することができる
　2.push_front() pop_front() push_back pop_back front() back() が使える
小技
　1.swap(vector,vector)で配列の中身を交換できる
　2.合格した人をvectorから取り除こうとするのではなくて合否をboolのvectorで保存すれば良いのだ
　3.vectorの初期化 a = vector<int>()もしくはa.clear()
　4.pair(-a,b)とすると良いことがあるかも. pairのsortはまずfirstが比較される
　5.


{
    "files.associations": {
        "vector": "cpp",
        "iosfwd": "cpp",
        "ostream": "cpp",
        "__split_buffer": "cpp",
        "string": "cpp",
        "functional": "cpp",
        "iomanip": "cpp",
        "iostream": "cpp",
        "tuple": "cpp",
        "bitset": "cpp",
        "numeric": "cpp",
        "algorithm": "cpp",
        "deque": "cpp",
        "stack": "cpp",
        "queue": "cpp",
        "__bit_reference": "cpp",
        "__bits": "cpp",
        "__config": "cpp",
        "__debug": "cpp",
        "__errc": "cpp",
        "__hash_table": "cpp",
        "__locale": "cpp",
        "__mutex_base": "cpp",
        "__node_handle": "cpp",
        "__nullptr": "cpp",
        "__string": "cpp",
        "__threading_support": "cpp",
        "__tree": "cpp",
        "__tuple": "cpp",
        "array": "cpp",
        "atomic": "cpp",
        "cctype": "cpp",
        "chrono": "cpp",
        "clocale": "cpp",
        "cmath": "cpp",
        "compare": "cpp",
        "complex": "cpp",
        "concepts": "cpp",
        "cstdarg": "cpp",
        "cstddef": "cpp",
        "cstdint": "cpp",
        "cstdio": "cpp",
        "cstdlib": "cpp",
        "cstring": "cpp",
        "ctime": "cpp",
        "cwchar": "cpp",
        "cwctype": "cpp",
        "exception": "cpp",
        "initializer_list": "cpp",
        "ios": "cpp",
        "istream": "cpp",
        "limits": "cpp",
        "locale": "cpp",
        "map": "cpp",
        "memory": "cpp",
        "mutex": "cpp",
        "new": "cpp",
        "optional": "cpp",
        "ratio": "cpp",
        "set": "cpp",
        "sstream": "cpp",
        "stdexcept": "cpp",
        "streambuf": "cpp",
        "string_view": "cpp",
        "system_error": "cpp",
        "type_traits": "cpp",
        "typeinfo": "cpp",
        "unordered_map": "cpp",
        "variant": "cpp",
        "cassert": "cpp",
        "list": "cpp",
        "__verbose_abort": "cpp",
        "bit": "cpp"
    }
}
うえはsettings.json


{
    "configurations": [
        {
            "name": "Mac",
            "includePath": [
                "${workspaceFolder}/**"
            ],
            "defines": [],
            "macFrameworkPath": [
                "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks"
            ],
            "compilerPath": "/usr/bin/clang",
            "cStandard": "c17",
            "cppStandard": "c++17",
            "intelliSenseMode": "macos-clang-arm64"
        }
    ],
    "version": 4
}

control + option + nでコンパイルと実行